right - left + 1 공식의 이해

`[1,2,3,4]`가 전부 유효한 값이라고 가정했을 때, 연속되는 서브어레이의 갯수를 구해야한다. 이 때, 기준이 되는 것은 오른쪽 포인터의 포함여부이다. 오른쪽 포인터를 포함하고 있는 서브어레이만 갯수에 더한다. 특정 순간에서 오른쪽 포인터(`right`)가 가리키는 원소를 포함하는 모든 가능한 서브어레이의 개수를 세기 위함이다.

`[1]`일 때는 `[1]`만 가능하므로 총 갯수는 하나이다.
`[1,2]`일 때는 `[2], [1,2]`가 가능하므로 총 갯수는 두 개이다. `[1]`은 오른쪽 포인터인 2를 포함하지 않는다.
`[1,2,3]`일 때는 `[3], [2,3], [1,2,3]`이 가능하므로 총 갯수는 세 개이다.
`[1,2,3,4]`일 때는 `[4], [3,4],[2,3,4], [1,2,3,4]`가 가능하므로 총 갯수는 네 개이다.

이를 반복하다보면 연속된 서브어레이가 지정된 윈도우의 길이만큼 생긴다는 것을 알 수 있다. 
따라서 서브어레이의 갯수를 구하는 공식은 `right - left + 1`이다.

슬라이딩 윈도우들의 문제는
- 조건을 만족하는 윈도우를 찾는다.이 때, 왼쪽 포인터는 고정시켜놓고, 오른쪽 포인터만 하나씩 오른쪽으로 옮겨가며 조건과 일치하는 윈도우를 찾는다.
- 조건을 만족하는 윈도우를 찾으면 정답을 계산하여 더한다.
- 왼쪽 포인터가 이동하는 경우는 조건을 초과하였을 경우다. 오른쪽 포인터가 이동하여 조건을 초과하였을 경우, 오른쪽 포인터는 더 이상 움직이지 않고 왼쪽 포인터가 하나씩 오른쪽으로 옮겨가며 조건에 맞는 윈도우를 찾는다.
- 조건에 맞는 윈도우를 찾았을 경우, 정답을 계산하여 더한다.
- 왼쪽 포인터는 정답을 계산한 곳에서 고정되고, 오른쪽 포인터가 움지기이기 시작한다.
- 오른쪽 포인터가 끝에 다다를 때까지 반복한다. 

LeetCode 2024년 3월 마지막주 내내 일일 챌린지가 sliding window문제였음... https://leetcode.com/problems/subarrays-with-k-different-integers/
