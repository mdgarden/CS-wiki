
*2023년 토스 NEXT 개발자 챌린지는 직군별 테스트 방식이 달라요. - 코딩테스트 : Core Banking, Server, Node.js (사용 플랫폼 : 프로그래머스) - 과제테스트 : Android, Frontend (사용 플랫폼 : 프로그래머스(Android), 이메일(Frontend)) 과제테스트는 요구사항에 따른 기능을 구현하는 문제로, 코딩테스트와는 형태와 풀이 방법이 다르니 참고해 주세요.]

## 가장 빠른 시간 내에 만점자가 나온 문제 : Frontend 직군

#### # 출제자의 한마디 이 문제는 76초만에 만점자가 나왔는데요. JavaScript에서 자주 보는 `undefined` 를 안전하게 다룰 수 있는 역량을 확인하고자 했어요. JavaScript의 내장 메서드와 기본적인 제어문을 활용하여 빠르게 요구사항에 맞는 함수를 구현할 수 있는지도 중요한 평가 요소였고요. JavaScript에서 제어문, 문자열 내장 메서드, 객체 자료구조에 대한 이해를 가지고 있고, 간단한 알고리즘 구현 역량을 가지고 있다면 맞출 수 있는 문제입니다.


### 문제명 : No More Undefined

김토스는 토스에서 외부 SDK를 연동하고 있습니다.

연동하던 중 아래와 같이 중간에 어떤 값이라도 `undefined` 일 수 있는 객체를 다뤄야 한다는 것을 알게 되었습니다.

``` js
/* repository가 undefined인 경우 */
const object1 = {
  repository: undefined,
};

/* repository의 readme가 undefined인 경우 */
const object2 = {
  repository: {
    readme: undefined,
  },
};

/** repository.readme 모두가 존재하는 경우 */
const object3 = {
  repository: {
    readme: {
      extension: 'md',
      content: '금융을 쉽고 간편하게',
    }
  }
};
```

위와 같은 객체를 쉽게 다룰 수 있도록 유틸리티 함수를 만들려고 합니다.

깊게 `undefined` 일 수 있는 객체의 값을 안전하게 가져올 수 있도록 `safelyGet` 함수를 구현해 주세요.

## 입출력 예시

```js
safelyGet(object1, 'repository.readme.extension')
// -> 반환 값: undefined

safelyGet(object1, 'repository.readme')
// -> 반환 값: undefined

safelyGet(object1, 'repository')
// -> 반환 값: undefined

safelyGet(object2, 'repository.readme.extension')
// -> 반환 값: undefined

safelyGet(object2, 'repository.readme')
// -> 반환 값: undefined

safelyGet(object2, 'repository')
// -> 반환 값: { readme: undefined }

safelyGet(object3, 'repository.readme.extension')
// -> 반환 값: 'md'

safelyGet(object3, 'repository.readme')
// -> 반환 값: { extension: 'md' }
```

### 조건

- `safelyGet` 함수는 첫 번째 인자로 객체를, 두 번째 인자로 문자열을 입력받습니다.
- 첫 번째 인자인 객체는 Plain object로만 입력됩니다. 배열이나 함수 등 Plain object가 아닌 객체는 고려하지 않습니다.
- 각 객체의 프로퍼티(Property)는 알파벳으로만 구성됩니다. 점(.)이나 숫자 등을 포함하는 경우는 고려하지 않습니다.
- 각 객체의 값(Value)은 문자열, undefined, 또는 그런 값을 가지는 Plain object만 고려합니다.
- 두 번째 인자인 문자열은 점(.)과 알파벳으로만 구성됩니다. 올바른 JavaScript 프로퍼티 접근 형식을 따릅니다. (`foo..bar`, `.foo`, `bar.` 와 같은 올바르지 않은 형태는 고려하지 않습니다.)

### 모범 답안

function safelyGet(object, path) {
  const properties = path.split('.');
  let current = object;

  for (const property of properties) {
    if (current === undefined) {
      return undefined;
    }
    current = current[property];
  }

  return current;
}

## ## 평균 체류 시간이 가장 긴 문제 : Android 직군

#### 출제자의 한마디 
이 문제는 평균 체류 시간이 1406초로 가장 길었는데요. 리스트를 정렬하는 등 실제로 업무에서 마주하는 문제를 해석하고 코드에 적용할 수 있는 역량이 있는지, 시간 안에 적절한 기술을 선택할 수 있는 역량이 있는지를 파악하고자 출제했어요. 정렬 조건을 잘 이해하고, Kotlin Collection Framework을 잘 활용한다면 쉽게 풀 수 있는 문제라고 생각해서, 평균적으로 100점 만점에 75점 정도는 나올 거라고 생각했어요.

### 문제명 : 토스 자산 목록 정렬

토스의 자산관리팀 김토스는 토스 창립 월인 13년도 4월부터 현재인 22년도 8월 까지 등록된 자산을 자산번호에 따라 오름차순으로 정렬하고 싶어 합니다. 토스의 자산번호 규칙은 반드시 아래의 9자리 문자열 순서로 구성되어 있으며, `[등록 연도 2자리]-[취급 자산 코드][등록 월 2자리][등록 순서 번호 2자리]` 1. 등록 연도 > 2. 취급 자산 코드 > 3. 등록 월 > 4. 등록 순서 번호 순서대로 정렬 우선순위를 가지고 있습니다. 각 구성요소의 설명은 아래 표를 참고 부탁드립니다.

  
예시) 22-MO0815 : 22년도 8월에 15번째로 등록한 모니터를 의미합니다.

![[Pasted image 20230705215950.png]]



### 자산번호 유효성 부가설명

반드시 9자리의 문자열이며, [조건] 목차에 설명된 유효성을 지켜야 합니다.

`
` 22-MO0815 (O) 23-MO0815 (X : 등록 연도는 현재 연도인 22년도를 넘을 수 없습니다.) 13-MO0315 (X : 등록 자산은 창립 월 이후인 13년도 4월부터 추가되는 자산을 의미합니다.) 22-MO0915 (X : 등록 자산은 현재 일자인 22년도 8월까지의 자산을 의미합니다.) 22-MO815 (X : 등록 월은 MM 형식으로 되어 있습니다.) 22MO0815 (X : '`-`' 문자가 빠져있습니다.) 22-MO08100 (X : 등록 번호는 99를 넘길 수 없습니다.) 22-MN0815 (X : MN 은 취급하는 자산이 아닙니다.)


### 구현 설명

[조건] 항목을 만족하는 아래와 같은 명세를 가진 함수를 구현해 주세요.

`fun solution(assets: Array<String>): Array<String>`


## 입출력 설명


![[Pasted image 20230705220042.png]]

### 모범 답안


```kotlin
class Solution {

    fun solution(assets: Array<String>): Array<String> =
        assets.mapNotNull { asset -> runCatching { asset.toAssetResult() }.getOrNull() }
            .sorted()
            .filter(Asset::isValid)
            .map(Asset::text)
            .distinct()
            .toTypedArray()

}

object ValidationError : Throwable()


fun String.toAssetResult(): Asset =
    when {
        length != 9 -> throw ValidationError
        slice(0..1).toIntOrNull() == null -> throw ValidationError
        get(2) != '-' -> throw ValidationError
        runCatching { Asset.Type.valueOf(slice(3..4)) }.isFailure -> throw ValidationError
        slice(5..6).toIntOrNull() == null -> throw ValidationError
        slice(7..8).toIntOrNull() == null -> throw ValidationError
        else -> Asset(
            text = this,
            yy = slice(0..1).toInt(),
            type = Asset.Type.valueOf(slice(3..4)),
            mm = slice(5..6).toInt(),
            no = slice(7..8).toInt()
        )
    }

data class Asset(
    val text: String,
    val yy: Int,
    val type: Type,
    val mm: Int,
    val no: Int
) : Comparable<Asset> {

    enum class Type {
        SP, KE, MO, CO, DE
    }

    val isValid: Boolean
        get() {
            return (yy in 13..22) && (mm in 1..12) && when {
                yy == 13 && mm < 4 -> false
                yy == 22 && mm > 8 -> false
                else -> true
            } && (no in 1..99)
        }

    override fun compareTo(other: Asset): Int {
        return when {
            yy > other.yy -> 1
            yy < other.yy -> -1
            type.ordinal > other.type.ordinal -> 1
            type.ordinal < other.type.ordinal -> -1
            mm > other.mm -> 1
            mm < other.mm -> -1
            no > other.no -> 1
            no < other.no -> -1
            else -> 0
        }
    }

}
```

## ## 만점자가 가장 많은 문제 : Core Banking/Server 직군

`
 ** 출제자의 한마디 **
이 문제는 만점자가 1435명으로 가장 많았는데요. 실제로도 난이도가 가장 낮은 문제로, Server 직군에 지원하는 지원자라면 반드시 맞추어야 하는 문제로 생각하고 출제했어요. 문자열과 반복문을 이용해 프로그래밍할 수 있는지 확인하는 기초적인 문제에요.``


### 문제명 : 멋쟁이 숫자

숫자로만 이루어진 문자열 s가 있습니다. (0 <=  s.length < 1,000) 아래의 조건을 모두 만족하는 숫자를 '멋쟁이 숫자'라고 합니다.

[조건] 1. 길이가 3인 s의 substring을 10진수로 읽은 숫자이다. 2. 각 자리의 숫자가 모두 같다.

### 구현사항

문자열s를 입력받아 멋쟁이 숫자를 리턴하는 함수를 만들어주세요.

- 만약, 멋쟁이 숫자가 여러 개 존재하는 경우에는 가장 큰 수를 리턴합니다.
- 만약, 가장 큰 멋쟁이 숫자가 000이라면 0을 리턴합니다.
- 만약, 멋쟁이 숫자가 존재하지 않다면 -1을 리턴합니다.

### 예시 문제

예시 1

- 입력: s = “12223”
- 출력: 222

예시 2

- 입력: s = “111999333”
- 출력: 999
- 설명: 111, 333, 999 3가지가 존재하고 999가 제일 크므로 999를 리턴합니다.

예시 3

- 입력: s = “123”
- 출력: -1

### 모범 답안

```kotlin
class Solution {
    fun solution(s: String): Int {
        var biggest = -1
        for (i in 0 until s.length-2) {
            if (s[i] == s[i+1] && s[i+1] == s[i+2]) {
                biggest = Math.max(biggest, s.substring(i, i+3).toInt())
            }
        }
        return biggest
    }
}
```

## ## 평균 점수가 가장 낮은 문제 : Node.js 직군

` #### 출제자의 한마디 이 문제는 특정 알고리즘에 대한 이해를 검증하기보다는, 실무에서 직면할 수 있는 문제를 해결하는 역량을 평가하고자 했어요. 순환을 가진 유향 그래프 순회의 이해와 활용, 타 개발자가 작성한 함수 혹은 API를 유연하게 활용하는 역량, 복잡한 도메인 로직을 효과적인 방법으로 코드로 전환하는 역량을 확인하고 싶었어요. 지원자의 10% 정도는 이 문제를 완전히 해결하고, 50% 정도는 부분적으로 점수를 받을 수 있을거라 예상했고요. 

### 문제명 : Lockfile을 만들어보자

김토스는 패키지 매니저라는 게 존재하는지 모르고 있었습니다. 똑똑한 김토스는, 설치 당시의 버전을 명시해주는 것이 얼마나 중요한지 깨달았는데요. 이를 위해, 설치 당시의 버전들을 명시하는 lockFile을 생성하는 함수를 제작하려고 합니다. 김토스를 도와 lockFile을 생성하는 solution 함수를 만들어 주세요.

### 문제 정의

- packageJson이 주어졌을 때, 해당 패키지의 의존성 및 각 의존성들의 의존성들을 재귀적으로 탐색하여 설치되어야 할 정확한 패키지의 `"이름@버전"` 배열을 반환해주세요. 중복은 제거해야 하며 순서는 상관없습니다.
- 탐색 방식과 순서에 따라서 설치되어야 할 패키지 버전이 바뀌면 안되며 한 패키지는 두가지 이상의 버전으로 설치될 수 있습니다. 이 알고리즘에 대해서는 하단 `결정적인 의존성 resolve 알고리즘`을 자세히 읽어주세요.

### ### 제약사항

- `packageJson` 오브젝트와 `fetchVersions`, `fetchPackageJson` 함수를 입력으로 받습니다.
- `fetchVersions` 함수는 패키지 이름을 입력 받아서 버전정보 배열을 반환합니다.

```js
const versions = await fetchVersions('foo');

//    ^^^^^^^^ 
// ["0.0.3", "1.0.0", "1.0.1", "1.1.0", "1.2.0"]
```

- `fetchPackageJson은` 함수는 패키지 이름과 버전을 입력 받아서 packageJson 객체를 반환합니다.
```js
const packageJson = await fetchPackageJson('foo', '1.0.0');

//    ^^^^^^^^ 
// {
//   "name": "foo",
//   "version": "1.0.0",
//   "dependencies": {
//     "bar": "^2.0.0",
//     "baz": "^1.0.0"
//   }
// }
```

- `packageJson`에는 `name`, `version`, `dependencies` 필드가 있습니다. `devDependencies는` 없다고 가정합니다.
```js
{
  "name": "my-package",
  "version": "1.0.0",
  "dependencies": {
    "foo": "^1.0.0",
    "bar": "~1.3.0"
    "baz": "0.0.1",
    "qux": "*"
  }
}
```

- `dependencies`는 패키지이름과 버전 범위의 레코드로 되어있습니다.
- `packageJson`의 `version` 필드에는 정확한 시맨틱 버전 정보가 선언되어 있으며 dependencies에 선언되어있는 버전은 시맨틱 버저닝의 범위를 표현하고 있습니다.
- 시맨틱 버저닝으로 표현된 버전 문자열에는 `.`으로 분리된 세 묶음의 숫자가 존재하며 각각을 `major`, `minor`, `patch`라고 합니다.
    
    - `major.minor.patch`의 형태이며 예를 들어 `1.0.0`의 경우 major는 1, minor는 0, 그리고 patch는 0이 됩니다.
    - 모든 버전은 세 묶음의 숫자로 이루어져 있습니다. 즉 `^1` 같은 표현은 존재하지 않습니다. 대신 `^1.0.0`으로 표현되어 있습니다.
    
- 시맨틱 버저닝의 범위 표현법에는 네가지 종류가 존재하며 각각이 뜻하는 의미는 다음과 같습니다.
    
    - `^1.0.0`: major가 동일해야 하며, minor와 patch는 가능한 가장 최신 버전을 사용해야 합니다.
    - `~1.3.0`: major와 minor가 동일해야 하며, patch는 가능한 가장 최신 버전을 사용해야 합니다.
    - `0.0.1`: 정확히 `0.0.1` 버전만 사용해야 합니다.
    - `*`: 모든 버전을 사용할 수 있으며 그중에서 가장 최신 버전을 사용해야 합니다.

### 결정적인 의존성 resolve 알고리즘

`foo` 패키지에는 `['1.0.0', '1.1.0']` 버전이 존재하고 `bar` 패키지에는 `['0.1.0', '0.2.0']` 버전이 존재한다고 가정합니다. `foo@1.1.0`은 `bar@*`를 의존하고 있으며 `bar`에는 의존성이 없습니다. 만약 `foo@^1.0.0`과 `bar@0.1.0`을 설치해야 한다고 했을 때, 의존성을 순회하는 두 가지 방식이 존재합니다.

- 너비 우선 탐색의 경우
    
    - `foo@^1.0.0` 범위의 가장 최신 버전인 `foo@1.1.0`이 설치됩니다.
    - `bar@0.1.0`은 해당 버전 그대로 `bar@0.1.0`이 설치됩니다.
    - `foo@1.1.0`은 앞서 말한대로 `bar@*`를 의존하고 있으며 `bar@*`에 해당하는 범위중 가장 최신인 `bar@0.2.0` 버전이 설치됩니다.
    - 따라서 프로젝트에는 `['foo@1.1.0', 'bar@0.1.0', 'bar@0.2.0']`이 설치됩니다.
    
- 깊이 우선 탐색의 경우
    
    - `foo@^1.0.0` 범위의 가장 최신 버전인 `foo@1.1.0`이 설치됩니다.
    - `foo@1.1.0`은 앞서 말한대로 `bar@*`를 의존하고 있으며 `bar@*`에 해당하는 범위중 가장 최신인 `bar@0.2.0` 버전이 설치됩니다.
    - `bar@0.1.0`은 해당 버전 그대로 `bar@0.1.0`이 설치됩니다.
    - 따라서 프로젝트에는 `['foo@1.1.0', 'bar@0.1.0', 'bar@0.2.0']`이 설치됩니다.
    

이 때 주의 깊게 봐야 할 점은 이미 설치되어야 할 버전 정보들이 추후 의존성을 탐색하는 과정에서 바뀌지 않는다는 것입니다. 너비 우선 탐색의 경우 `bar@0.1.0`이 이미 설치된 상태에서 `bar@*` 범위의 의존성을 설치하고 있습니다. 이 때 `bar@0.1.0`은 `bar@*`에 포함되기 때문에 설치를 건너뛸 수 있다고 생각할 수 있는데, 그렇게 하면 안 됩니다. `bar@0.2.0`이 더 최신이므로 해당 버전을 설치해야 합니다. 이 알고리즘은 중복 패키지를 최소화하는 게 목적이 아니기 때문입니다.

### 입출력 형태
#### 입력 값

```js
const packageJson = {
  name: 'my-package',
  version: '1.0.0',
  dependencies: {
    foo: '^1.0.0'
  }
};

async function fetchVersions(packageName) { ... }

async function fetchPackageJson(packageName, version) { ... }

solution(packageJson, fetchVersions, fetchPackageJson);
```

#### 반환 값

```js
[
  'bar@1.3.2',
  'baz@10.1.0',
  'baz@11.0.20',
  'corge@17.1.4',
  'foo@1.2.1',
  'qux@3.1.3',
  'thud@4.50.1',
]
```

#### 모범 답안


```js
async function solution(packageJson, fetchVersions, fetchPackageJson) {
    const versions = {};
    await resolveVersion(packageJson);
    return flattenVersions(versions);

    async function resolveVersion(packageJson) {
        const packagesToDownload = Object.entries(packageJson.dependencies);
        for (const [packageName, rawSemver] of packagesToDownload) {
            if (!(packageName in versions)) {
                versions[packageName] = {
                    matched: new Map(),
                    availables: await fetchVersions(packageName).then(sort),
                };
            }
            const { matched, availables } = versions[packageName];
            if (matched.has(rawSemver)) {
                continue;
            }

            const semver = NodeSemver.of(rawSemver);
            const highestPossibleVersion = availables.find(candidate =>
                semver.canAccept(candidate)
            );
            matched.set(rawSemver, highestPossibleVersion);
            const nextPackageJson = await fetchPackageJson(packageName, highestPossibleVersion);
            await resolveVersion(nextPackageJson);
        }
    }
}

function flattenVersions(versions) {
    const packageNames = Object.keys(versions);
    const lockFile = [];
    for (const packageName of packageNames) {
        const { matched } = versions[packageName];
        const versionCandidates = Array.from(new Set(matched.values()));
        lockFile.push(...versionCandidates.map(version => `${packageName}@${version}`));
    }
    return lockFile;
}

function sort(rawVersions) {
    return rawVersions
        .map(version => NodeSemver.of(version))
        .sort(NodeSemver.sort)
        .map(nodeSemver => nodeSemver.version);
}

class NodeSemver {
    constructor(version, type, major, minor, patch) {
        this.version = version;
        this.type = type;
        this.major = major;
        this.minor = minor;
        this.patch = patch;
    }

    static sort(s1, s2) {
        if (s1.major > s2.major) return -1;
        if (s1.major === s2.major) {
            if (s1.minor > s2.minor) return -1;
            if (s1.minor === s2.minor) {
                return s1.patch >= s2.patch ? -1 : 1;
            }
            return 1;
        }
        return 1;
    }

    static of(rawSemver) {
        if (rawSemver === '*') {
            return new NodeSemver(rawSemver, 'all', null, null, null);
        }

        let type, version;

        if (rawSemver.startsWith('^')) {
            version = rawSemver.slice(1);
            type = 'major';
        } else if (rawSemver.startsWith('~')) {
            version = rawSemver.slice(1);
            type = 'minor';
        } else {
            version = rawSemver;
            type = 'exact';
        }

        const [major, minor, patch] = version.split('.').map(digit => parseInt(digit));
        return new NodeSemver(version, type, major, minor, patch);
    }

    canAccept(exactVersion) {
        const target = NodeSemver.of(exactVersion);
        if (target.type !== 'exact') {
            throw new Error(`Cannot calculate acceptability with version: ${exactVersion}`);
        }

        switch (this.type) {
            case 'all':
                return true;
            case 'exact':
                return exactVersion === this.version;
            case 'major':
                // major는 같아야 하고
                return target.major === this.major &&
                    // minor가 같은 경우 patch를 비교
                    target.minor === this.minor
                    ? target.patch >= this.patch
                    : target.minor > this.minor;
            case 'minor':
                return (
                    target.major === this.major &&
                    target.minor === this.minor &&
                    target.patch >= this.patch
                );
        }
        return false;
    }
}

module.exports.solution = solution;
```