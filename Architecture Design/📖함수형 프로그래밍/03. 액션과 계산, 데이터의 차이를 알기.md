---
tags:
  - 액션과_계산_데이터
---
>[!abstract]
>### 이번 장에서 살펴볼 내용
>- 액션과 계산, 데이터가 어떻게 다른지 배움
>- 문제에 대해 생각하거나 코드를 작성할 때 또는 코드를 읽을 때 액션과 계산, 데이터를 구분해서 적용함
>- 액션이 코드 전체로 퍼질 수 있다는 것을 이해함
>- 이미 있는 코드에서 어떤 부분이 액션인지 찾아봄

## 액션과 계산, 데이터
| 액션                                                                                                     | 계산                                                                | 데이터                                  |
| ------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------- | ------------------------------------ |
| 실행 시점과 횟수에 의존함                                                                                         | 입력으로 출력을 계산함                                                      | 이벤트에 대한 사실                           |
| 다른 말로 부수 효과(side-effects), 부수 효과가 있는 함수(side-effecting function), 순수하지 않은 함수(impure function)라고 부르기도 함 | 다른 말로 순수 함수(pure function), 수학 함수(mathematical function)라고 부르기도 함 |                                      |
| 예) 이메일 보내기, 데이터 베이스 읽기                                                                                 | 예) 최댓값 찾기, 이메일 주소가 올바른지 확인하기                                      | 예) 사용자가 입력한 이메일 주소, 은행 API로 읽은 달러 수량 |
> [!note]
> 계산은 계산을 호출하는 코드를 계산 결과로 바꿀 수 있기 때문에 참조 투명(referentially transparent)함. 2 + 3의 예에서, +는 계산이기 때문에 2 + 3의 결과는 항상 5임. 그래서 2 + 3 이라는 코드를 5라는 결괏값으로 바꿔도 프로그램이 달라지지 않음. 다른 말로 하면 2 + 3 코드의 결과는 항상 같기 때문에 여러 번 불러도 문제가 없다는 뜻.

- 모든 개발 과정에서 액션과 계산, 데이터를 구분하는 기술을 적용할 수 있음
	- 1단계 : 문제에 대해 생각할 때
		- 코딩을 시작하기 전이고 문제에 대해서 고민하고 있을 때도 문제를 액션과 계산, 데이터로 나눠 생각해볼 수 있음.
		- 문제를 액션과 계산, 데이터로 나눠보면 코드를 작성할 때 특별히 주의해야 할 부분(액션)과 데이터로 처리해야 할 부분, 결정을 내려야 하는 부분(계산)을 명확히 알 수 있음
	- 2단계 : 코딩할 때
		- 코딩을 할 때도 액션과 계산, 데이터를 구분할 수 있음
		- 함수형 프로그래머는 최대한 액션에서 계산을 빼내려고 하고, 계산에서 데이터를 분리할 수 있는지 생각함
		- 액션이 계산이 될 수 있는지, 계산은 데이터가 될 수 있는지 고민함
	- 3단계 : 코드를 읽을 때
		- 코드를 읽을 때 액션과 계산, 데이터 중 어떤 것에 속하는지 살펴봐야 함
		- 액션은 시간에 의존하기 때문에 더 조심해야하며, 숨어있는 액션까지 찾아내야 함.
> [!note]
> 액션은 호출 시점과 횟수에 의존함
> 
>	- 냉장고 확인하기 - 냉장고를 확인하는 시점에 따라 냉장고에 있는 제품이 다르기 때문에 액션. 냉장고 안에 있는 제품은 데이터.
>	- 운전해서 상점으로 가기 - 두 번 운전해서 상점에 가면 연료가 두 배로 듦. 상점 위치, 가는 경로는 데이터.
>	- 필요한 것 구입하기 - 누군가 브로콜리를 구입하면 브로콜리가 없을 수도 있기 때문
>	- 운전해서 집으로 오기 - 이미 집에 있다면 상점에서 집으로 올 수 없음.(실행 시기가 중요함)

## 장보기 과정에서 배운 것
- 액션과 계산, 데이터는 어디에나 적용할 수 있음
- 액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을 수 있음
- 계산은 더 작음 계산과 데이터로 나누고 연결할 수 있음
- 데이터는 데이터만 조합할 수 있음
- 계산은 때로 우리 머릿속에서 일어남
	- 장을 보는 상황에서 무엇을 사야할지는 머릿속에서 저절로 생각남(계산이 사고 과정에 녹아있음)

> [!note]
> ### 데이터에 대해 자세히 알아보기
> - 데이터는 무엇인가?
> 	- 데이터는 이벤트에 대한 사실. 일어난 일의 결과를 기록한 것.
> - 데이터를 어떻게 구현하는가?
> 	- 자바스크립트에서는 기본 데이터 타입으로 구현함. 숫자나 문자, 배열, 객체 같은 것. 다른 언어에서는 더 정교한 방법으로 데이터를 만들 수 있음.
> 	- 하스켈은 새로운 데이터 타입을 정의해 도메인을 표현함
> - 어떻게 데이터에 의미를 담을 수 있는가?
> 	- 데이터 구조로 의미를 담을 수 있음. 목록의 순서가 중요하다면 순서를 보장하는 데이터 구조를 사용하면 됨.
> 	- 데이터 구조로 도메인을 표현할 수 있음
> - 불변성
> 	- 함수형 프로그래머는 불변 데이터 구조를 만들기 위해 두 가지 원칙을 사용함
> 	- 1. 카피-온-라이트 copy-on-write, 변경할 때 복사본을 만듦
> 	- 2. 방어적 복사 defensive copy, 보관하려고 하는 데이터의 복사본을 만듦
> 	- 이 원칙은 [[06. 변경 가능한 데이터 구조를 가진 언어에서 불변성을 유지하기 | 6장]]과 [[07. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기 | 7장]]에서 다룰 예정
> - 데이터의 예
> 	- 구입하려는 음식 목록
> 	- 이름
> 	- 전화 번호
> 	- 음식 조리법
> - 데이터의 장점은?
> 	- 역설적으로 데이터는 데이터 자체로 할 수 있는 것이 없기 때문에 좋음
> 	- 데이터는 데이터 그대로 이해할 수 있음
> 		- 1. ==직렬화== 
> 			- 직렬화된 액션과 계산은 다른 곳에서 잘 동작할 것이라는 보장이 없음
> 			- 하지만 직렬화된 데이터는 전송하거나 디스크에 저장했다가 읽기 쉬움
> 		- 2. ==동일성 비교==
> 			- 계산이나 액션은 서로 비교하기 어려우나 데이터는 비교하기 쉬움
> 		- 3. ==자유로운 해석==
> 			- 데이터는 여러 가지 방법으로 해석할 수 있음
> 			- 접속 로그는 문제 해결을 위해 사용할 수 있지만, 모니터링을 위해 사용할 수도 있음
> - 데이터의 단점은?
> 	- 유연하게 해석할 수 있다는 점은 장점
> 	- 해석이 반드시 필요하다는 점은 단점
> 	- 계산은 해석하지 않아도 실행할 수 있음
> 	- 해석하지 않은 데이터는 쓸모없는 바이트일 뿐임

> [!important]
> 데이터를 언제나 쉽게 해석할 수 있도록 표현하는 것이 함수형 프로그래밍에서 중요한 기술임


## 쿠폰 보내는 과정을 그려보기

### 1. 데이터베이스에서 구독자를 가져오기
- 데이터베이스에서 구독자를 가져오는 것은 ==액션==
	- 구독자는 계속 바뀌기 때문에 지금 가져온 구독자와 다음에 가져온 구독자는 다를 수 있음
	- 따라서 실행 시점에 의존하기 때문에 액션임
	- 구독자를 데이터베이스에서 가져오면 사용자 목록을 얻을 수 있고, 이것은 ==데이터==

### 2. 데이터베이스에서 쿠폰 목록 가져오기
- 데이터베이스에서 쿠폰 목록을 가져오는 것은 ==액션==
	- 쿠폰 데이터베이스는 계속 바뀌기 때문
	- 쿠폰 목록은 ==데이터==
	- 쿠폰 목록 데이터는 DB 쿼리 이벤트에 대한 사실이라고 할 수 있음

### 3. 보내야 할 이메일 목록 만들기

| 액션              | 계산          | 데이터    |
| --------------- | ----------- | ------ |
| DB에서 구독자 가져오기   |             | 구독자 목록 |
| DB에서 쿠폰 목록 가져오기 |             | 쿠폰 목록  |
|                 | 이메일 목록 계획하기 | 이메일 목록 |

### 4. 이메일 전송하기

| 액션              | 계산          | 데이터    |
| --------------- | ----------- | ------ |
| DB에서 구독자 가져오기   |             | 구독자 목록 |
| DB에서 쿠폰 목록 가져오기 |             | 쿠폰 목록  |
|                 | 이메일 목록 계획하기 | 이메일 목록 |
| 이메일 보내기         |             |        |
### 이메일 만드는 부분을 자세히 살펴보기
- 함수형 프로그래머가 아니라면 이메일을 보내기 전에 이메일 목록 전체를 미리 만드는 것이 이상하다고 생각할 수 있습니다.
	- 일반적으로 이메일을 보낼 때 본문을 만들어 보내기도 함
- 함수형 프로그래머는 일반적으로 가능하면 액션을 쓰지 않으려고 함
	- 계산으로 바꿀 수 있는 액션이 있다면 그렇게 하는 것이 좋다고 생각함
	- 가능한 계산을 사용하려고 하는 이유는 테스트하기 쉽기 때문
	- 이메일을 실제로 보내고 결과를 주는 시스템은 테스트하기 어렵지만, 결과가 이메일 목록 데이터인 시스템은 테스트하기 쉬움
	- 계산은 외부에 영향을 받지 않기 때문에 여러번 테스트해도 문제가 없음

- 쿠폰 목록에서 'good'쿠폰 목록과 'best' 쿠폰 목록을 계산할 수 있음

| 계산           | 데이터        |
| ------------ | ---------- |
|              | 구독자 목록     |
| good 쿠폰 선택하기 | good 쿠폰 목록 |
| best 쿠폰 선택하기 | best 쿠폰 목록 |
- 어떤 구독자가 good 쿠폰을 받을지 best 쿠폰을 받을지 결정하는 것을 계산으로 만들 수 있음

| 계산         | 데이터   |
| ---------- | ----- |
|            | 구독자   |
| 쿠폰 등급 결정하기 | 쿠폰 등급 |

## 쿠폰 보내는 과정 구현하기
### 데이터베이스에서 가져온 구독자 데이터
- 구독자 데이터는 이메일 데이터베이스 테이블에서 가져온 것
- 자바스크립트에서는 데이터베이스 행을 표현하기 위해 자바스크립트 객체를 사용

```ts
interface Subscriber = {
  email : string,
  rec_count: number;
}
const subsriber = {
  email : "sam@pmail.com",
  rec_count : 16,
};
```

### 쿠폰 등급은 문자열
- 쿠폰 등급은 문자열로 표현
```ts
const RANK_1ST = "best";
const RANK_2ND = "good"
```

### 쿠폰 등급을 결정하는 것은 함수
- 자바스크립트에서 계산은 함수로 구현함
- 입력값은 함수 인자이고 출력값은 함수의 리턴값

> [!note]
> - 계산은 입력값으로 출력값을 만드는 것
> - 호출 시점이나 횟수에 의존하지 않고 동일한 입력값으로 부르면 항상 같은 결괏값을 돌려줌
> - 

```ts
fucntion subCouponRank(subscriber: Subscriber) {
  subscriber.rec_count >= 10 ? RANK_1ST : RANK_2ND;
}
```

### 데이터베이스에서 가져온 쿠폰 데이터
```ts
// 열거형 정의
enum Rank {
  Best = "best",
  Good = "good",
  Bad = "bad"
}

// 인터페이스 정의
interface Coupon {
  code: string;
  rank: Rank;
}

const coupon =  {
  code: "10PERCENT",
  rank: Rank.Bad
}

```

### 특정 등급의 쿠폰 목록을 선택하는 계산은 함수
- 입력값은 전체 쿠폰 목록과 선택할 등급, 출력값은 선택한 등급을 가진 쿠폰 목록
```ts
function selectCouponsByRank(coupons: Coupon[], rank) {
  const ret = [];
  for(let c = 0; c < coupons.length; c++) {
    const coupon = coupons[c];
    if(coupon.rank === rank) ret.push(coupon.code);
  }
  return ret;
}
```

### 이메일은 그냥 데이터임
```ts
const message = {
  from: "newsletter@coupondog.co",
  to: "sam@pmail.com",
  subject: "Your weekly coupons inside",
  body: "Here are your coupons ..."
}
```

### 구독자가 받을 이메일을 계획하는 계산
```ts
function emailForSubscriber(subscriber,goods, bests) {
  const rank = subCouponRank(subscriber);
  if (rank === Rank.Best) return {
    from: "newletter@coupondog.co",
    to: subscriber.email,
    subject: "Your best weekly coupons inside",
    body: "Here are the best coupons: " + bests.join(", ")
  } else {
	  return {...} // good 쿠폰 이메일 본문 모내기
  }
}
```

### 최종 구현된 코드

```ts
// 리팩토링 전, 책 그대로 옮긴 코드
function sendIssue() {
  var coupons = fetchCouponsFromDB();
  var goodCoupons = selectCouponsByRank(coupons, "good");
  var bestcoupons = selectCouponsByRank(coupons, "best");
  var subscribers = fetchSubscribersFromDB();
  var email = emailsForSubscribers(subscribers, goodCoupons, bestCoupons);
  for(var e = 0; e < emails.length; e++) {
    var email = emails[e];
    emailSystem.send(email);
  }
}
```

> [!note]
> 일반적인 구현 순서
> 1. 데이터
> 2. 계산
> 3. 액션


## 액션은 코드 전체로 퍼짐
> [!warning]
> 액션을 부르는 함수가 있다면 그 함수도 액션이 됨. 그 함수를 부르는 다른 함수도 역시 액션이 됨. 작은 액션 하나가 코드 전체로 퍼져나갈 수 있음

- 함수형 프로그래머는 액션을 가능한 사용하지 않아야 함
- 액션을 쓰는 순간 코드 전체로 퍼져나가기 때문에 사용할 때 조심해야함
- 함수형 사고의 많은 부분이 액션을 잘 다루기 위한 내용이기도 함
- 

## 액션은 다양한 형태로 나타남
- 액션을 관리하기 위해서 액션이 코드에서 어떤 형태로 나타나는지 알아야함

- 함수 호출 `alert("Hello world!)`
- 메서드 호출 `console.log("hello")`
- 생성자 `new Date()`
- 표현식
	- 변수 참조 `y` (y가 공유되고 변경 가능한 함수라면 읽는 시점에 따라 값이 다름)
	- 속성 참조 `user.first_name` (user가 공유되고 변경 가능한 객체라면 first_name은 읽는 시점에 따라 값이 다를 수 있음)
	- 배열 참조 `stack[0]` (stack이 공유되고 변경 가능한 배열이라면 첫 번째 항목은 읽는 시점에 따라 값이 다를 수 있음)
	- 상태 `값 할당, 속성 삭제`


## 결론
- 계산은 계획이나 결정을 할 때 적용
- 데이터는 계획하거나 결정한 결과
- 액션을 통해 계산으로 만든 계획을 실행함

## 요점 정리
- 함수형 프로그래머는 액션과 계산, 데이터를 구분함
- 액션은 실행 시점이나 횟수에 의존함. 일반적으로 액션은 외부 세계에 영향을 주거나 받음
- 계산은 입력값으로 출력값을 만드는 것. 외부 세계에 영향을 주거나 받지 않고 실행 시점이나 횟수에 의존하지 않음
- 데이터는 이벤트에 대한 사실. 사실은 변하지 않기 때문에 영구적으로 기록할 수 있음.
- 함수형 프로그래머는 액션보다 계산을 좋아하고 계산보다 데이터를 좋아함
- 계산은 같은 입력값을 주면 항상 같은 출력값이 나오기 때문에 액션보다 테스트하기 위움